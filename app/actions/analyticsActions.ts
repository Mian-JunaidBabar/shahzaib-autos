"use server";

import { prisma } from "@/lib/prisma";
import { startOfDay, endOfDay, eachDayOfInterval, format } from "date-fns";

// Date range type used by all analytics functions
export type DateRange = {
  startDate: Date;
  endDate: Date;
};

// Helper to get default date range (last 30 days) - internal only
function getDefaultDateRange(): DateRange {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - 29);
  return {
    startDate: startOfDay(startDate),
    endDate: endOfDay(endDate),
  };
}

export async function getRevenueOverTime(range?: DateRange) {
  const { startDate, endDate } = range || getDefaultDateRange();

  // Ensure proper day boundaries
  const start = startOfDay(startDate);
  const end = endOfDay(endDate);

  // Fetch orders within the date range
  const orders = await prisma.order.findMany({
    where: {
      status: { in: ["CONFIRMED", "SHIPPED", "DELIVERED"] },
      createdAt: { gte: start, lte: end },
    },
    select: {
      total: true,
      createdAt: true,
    },
  });

  // Group by date string (YYYY-MM-DD)
  const groupedData: Record<string, { revenue: number; orders: number }> = {};

  // Initialize all dates in the range to ensure zero fill
  const allDays = eachDayOfInterval({ start, end });
  allDays.forEach((day) => {
    const dateStr = format(day, "yyyy-MM-dd");
    groupedData[dateStr] = { revenue: 0, orders: 0 };
  });

  orders.forEach((order) => {
    const dateStr = format(order.createdAt, "yyyy-MM-dd");
    if (groupedData[dateStr]) {
      groupedData[dateStr].revenue += order.total / 100; // Convert cents to dollars/rupees display unit
      groupedData[dateStr].orders += 1;
    }
  });

  return Object.entries(groupedData).map(([date, data]) => ({
    date,
    revenue: data.revenue,
    orders: data.orders,
  }));
}

export async function getTopSellingProducts(range?: DateRange) {
  const { startDate, endDate } = range || getDefaultDateRange();
  const start = startOfDay(startDate);
  const end = endOfDay(endDate);

  // Find order items from orders within the date range
  const topItems = await prisma.orderItem.groupBy({
    by: ["productId", "name"],
    where: {
      order: {
        createdAt: { gte: start, lte: end },
      },
    },
    _sum: {
      quantity: true,
    },
    orderBy: {
      _sum: {
        quantity: "desc",
      },
    },
    take: 5,
  });

  return topItems.map((item) => ({
    name: item.name,
    quantity: item._sum.quantity || 0,
    productId: item.productId,
  }));
}

export async function getBookingStatusDistribution(range?: DateRange) {
  const { startDate, endDate } = range || getDefaultDateRange();
  const start = startOfDay(startDate);
  const end = endOfDay(endDate);

  const distribution = await prisma.booking.groupBy({
    by: ["status"],
    where: {
      createdAt: { gte: start, lte: end },
    },
    _count: {
      id: true,
    },
  });

  return distribution.map((item) => ({
    name: item.status,
    value: item._count.id,
  }));
}

export async function getDashboardSummary(range?: DateRange) {
  const { startDate, endDate } = range || getDefaultDateRange();
  const start = startOfDay(startDate);
  const end = endOfDay(endDate);

  // Run queries sequentially to avoid opening many DB sessions at once
  const totalRevenueResult = await prisma.order.aggregate({
    where: {
      status: { in: ["CONFIRMED", "SHIPPED", "DELIVERED"] },
      createdAt: { gte: start, lte: end },
    },
    _sum: {
      total: true,
    },
  });

  const pendingOrders = await prisma.order.count({
    where: {
      status: { in: ["NEW", "PROCESSING"] },
      createdAt: { gte: start, lte: end },
    },
  });

  const activeBookings = await prisma.booking.count({
    where: {
      status: { in: ["PENDING", "CONFIRMED", "IN_PROGRESS"] },
      createdAt: { gte: start, lte: end },
    },
  });

  const lowStockItems = await prisma.inventory.count({
    where: {
      quantity: { lte: 10 },
    },
  });

  return {
    totalRevenue: (totalRevenueResult._sum.total || 0) / 100, // Cents to main unit
    pendingOrders,
    activeBookings,
    lowStockItems,
  };
}

export async function getCustomerGrowth(days: number = 30) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - days);

  const customers = await prisma.customer.findMany({
    where: {
      createdAt: { gte: cutoffDate },
    },
    select: { createdAt: true },
  });

  const groupedData: Record<string, number> = {};

  for (let i = days - 1; i >= 0; i--) {
    const d = new Date();
    d.setDate(d.getDate() - i);
    const dateStr = d.toISOString().split("T")[0];
    groupedData[dateStr] = 0;
  }

  customers.forEach((customer) => {
    const dateStr = customer.createdAt.toISOString().split("T")[0];
    if (dateStr in groupedData) {
      groupedData[dateStr] += 1;
    }
  });

  return Object.entries(groupedData).map(([date, newCustomers]) => ({
    date,
    newCustomers,
  }));
}

export async function getRevenueByCategory(range?: DateRange) {
  const { startDate, endDate } = range || getDefaultDateRange();
  const start = startOfDay(startDate);
  const end = endOfDay(endDate);

  const orderItems = await prisma.orderItem.findMany({
    where: {
      order: {
        createdAt: { gte: start, lte: end },
      },
    },
    include: {
      product: { select: { category: true, price: true } },
    },
  });

  const categoryTotals: Record<string, number> = {};

  orderItems.forEach((item) => {
    const cat = item.product?.category || "Uncategorized";
    if (!categoryTotals[cat]) categoryTotals[cat] = 0;
    categoryTotals[cat] += (item.price * item.quantity) / 100;
  });

  return Object.entries(categoryTotals)
    .map(([name, value]) => ({
      name,
      value,
    }))
    .sort((a, b) => b.value - a.value)
    .slice(0, 5);
}

export async function getTopBookedServices() {
  const services = await prisma.booking.groupBy({
    by: ["serviceType"],
    _count: {
      id: true,
    },
    orderBy: {
      _count: {
        id: "desc",
      },
    },
    take: 5,
  });

  return services.map((s) => ({
    name: s.serviceType,
    bookings: s._count.id,
  }));
}

export async function getLowStockAlerts() {
  const alerts = await prisma.inventory.findMany({
    where: {
      quantity: { lte: 10 },
    },
    include: {
      product: { select: { name: true, sku: true } },
    },
    take: 5,
    orderBy: {
      quantity: "asc",
    },
  });

  return alerts.map((a) => ({
    id: a.id,
    name: a.product.name,
    sku: a.product.sku,
    quantity: a.quantity,
    threshold: a.lowStockAt,
  }));
}
